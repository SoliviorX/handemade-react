(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

	const FunctionComponent = 0;
	// ReactDOM.render(xxx) 对应的根节点类型
	const HostRoot = 3;
	// 普通元素节点的类型
	const HostComponent = 5;
	// 文本节点的类型
	const HostText = 6;

	const NoFlags = 0b0000001;
	const Placement = 0b0000010;
	const Update = 0b0000100;
	const ChildDeletion = 0b0001000;
	const MutationMask = Placement | Update | ChildDeletion;

	/**
	 * current fiber 和 wip fiber 中的 alternate 字段：
	 * 当 react 的状态发生更新时，当前页面所对应的 fiber 树称为 current Fiber，同时 react 会根据新的状态构建一颗新的 fiber 树，称为 workInProgress Fiber。current Fiber 中每个 fiber 节点通过 alternate 字段，指向 workInProgress Fiber 中对应的 fiber 节点。同样 workInProgress Fiber 中的 fiber
	节点的 alternate 字段也会指向 current Fiber 中对应的 fiber 节点。
	 */
	class FiberNode {
	    type;
	    tag;
	    pendingProps;
	    key;
	    stateNode;
	    ref;
	    return;
	    sibling;
	    child;
	    index;
	    memoizedProps;
	    memoizedState;
	    alternate;
	    flags;
	    subtreeFlags; // 子树中的flags
	    updateQueue;
	    constructor(tag, pendingProps, key) {
	        // 实例
	        this.tag = tag;
	        this.key = key;
	        this.stateNode = null; // HostComponent 的 DOM
	        this.type = null; // FunctionComponnet 的函数
	        // 构成树状结构
	        this.return = null; // 父 fiberNode
	        this.sibling = null; // 右边的同级 fiberNode
	        this.child = null; // 子 fiberNode
	        this.index = 0; // 所处同级 fiberNode 的索引
	        this.ref = null;
	        // 作为工作单元
	        this.pendingProps = pendingProps;
	        this.memoizedProps = null;
	        this.memoizedState = null;
	        this.updateQueue = null;
	        // 副作用
	        this.flags = NoFlags;
	        this.subtreeFlags = NoFlags;
	        this.alternate = null;
	    }
	}
	class FiberRootNode {
	    // container 的类型不能直接设为 DomElement，因为只有根节点（ReactDOM.createRoot(rootElement)）才有DomElement
	    container;
	    current;
	    // 更新完成以后的 hostRootFiber
	    finishedWork;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        // fiberRootNode.current = hostRootFiber
	        this.current = hostRootFiber;
	        // hostRootFiber.stateNode = fiberRootNode
	        hostRootFiber.stateNode = this;
	        this.finishedWork = null;
	    }
	}
	const createWorkInProgress = (current, pendingProps) => {
	    let wip = current.alternate;
	    if (wip === null) {
	        // mount
	        wip = new FiberNode(current.tag, pendingProps, current.key);
	        wip.type = current.type;
	        wip.stateNode = current.stateNode;
	        wip.alternate = null;
	        current.pendingProps = pendingProps;
	    }
	    else {
	        // update
	        wip.type = current.type;
	        wip.flags = NoFlags;
	        wip.subtreeFlags = NoFlags;
	    }
	    wip.type = current.type;
	    wip.updateQueue = current.updateQueue;
	    wip.child = current.child;
	    wip.memoizedProps = current.memoizedProps;
	    wip.memoizedState = current.memoizedState;
	    return wip;
	};
	function createFiberElement(element) {
	    const { type, key, props } = element;
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        // <div/> ——> type: 'div'
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('未定义的type类型');
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	// 创建 update 实例
	const createUpdate = (action) => {
	    return {
	        action
	    };
	};
	// 创建 UpdateQueue 实例
	const createUpdateQueue = () => {
	    return {
	        shared: {
	            pending: null
	        }
	    };
	};
	// 往 UpdateQueue 里增加 update
	const enqueueUpdate = (updateQueue, update) => {
	    updateQueue.shared.pending = update;
	};
	// 在 updateQueue 中消费 update
	const processUpdateQueue = (baseState, pendingUpdate) => {
	    const result = {
	        // 设置一个初始值
	        memoizedState: baseState
	    };
	    // 如果待执行的update（pendingUpdate）存在
	    if (pendingUpdate !== null) {
	        const action = pendingUpdate.action;
	        if (action instanceof Function) {
	            // baseState = 1; update = (x) => 4 * x ------> memoizedState = 4
	            result.memoizedState = action(baseState);
	        }
	        else {
	            // baseState = 1; update = 2 ------> memoizedState = 2
	            result.memoizedState = action;
	        }
	    }
	    return result;
	};

	// 判断当前环境是否支持 Symbol：Symbol是构造函数；Symbol.for(key)通过key找到对应的symbol值，如果没找到则通过该key创建一个symbol值。
	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0xeac7; // 不支持 Symbol 则将reactElementType设为一个数字

	function ChildReconciler(shouldRtackEffects) {
	    function reconcileSingleElement(returnFiber, currentFiber, element) {
	        // 根据element创建fiber
	        const fiber = createFiberElement(element);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    function reconcileSingleTextNode(returnFiber, currentFiber, content) {
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    // 插入单一节点
	    function placeSingleChild(fiber) {
	        // 传参的 fiber 是 workInProgress fiber，则 fiber.alternate 指的是 current fiber，当它是null时表示首屏渲染
	        if (shouldRtackEffects && fiber.alternate === null) {
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    }
	    return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
	        // 判断当前 fiber 类型
	        if (typeof newChild === 'object' && newChild !== null) {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
	                default:
	                    {
	                        console.warn('未实现的reconcile类型');
	                    }
	                    break;
	            }
	        }
	        // TODO 多节点处理 ul > li*3
	        // HostText
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
	        }
	        {
	            console.warn('未实现的reconcile类型');
	        }
	        return null;
	    };
	}
	const reconcileChildFibers = ChildReconciler(true);
	const mountChildFibers = ChildReconciler(false);

	// 递归中的递阶段
	const beginWork = (wip) => {
	    // 比较 ReactElement 和 fiberNode，返回子 fiberNode
	    switch (wip.tag) {
	        case HostRoot:
	            return updateHostRoot(wip);
	        case HostComponent:
	            return updateHostComponent(wip);
	        case HostText:
	            // HostText 没有子节点，直接返回null
	            return null;
	        default:
	            {
	                console.warn('beginWork未实现的类型');
	            }
	            break;
	    }
	    return null;
	};
	function updateHostRoot(wip) {
	    const baseState = wip.memoizedState;
	    const updateQueue = wip.updateQueue;
	    const pending = updateQueue.shared.pending;
	    updateQueue.shared.pending = null;
	    // 计算状态的最新值
	    const { memoizedState } = processUpdateQueue(baseState, pending);
	    wip.memoizedState = memoizedState;
	    const nextChildren = wip.memoizedState;
	    // 创造子fiberNode
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	function updateHostComponent(wip) {
	    const nextProps = wip.pendingProps;
	    const nextChildren = nextProps.children;
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	function reconcileChildren(wip, children) {
	    const current = wip.alternate;
	    if (current !== null) {
	        // update
	        wip.child = reconcileChildFibers(wip, current?.child, children);
	    }
	    else {
	        // mount
	        wip.child = mountChildFibers(wip, null, children);
	    }
	}

	const createInstance = (type, props) => {
	    // TODO 处理 props
	    const element = document.createElement(type);
	    return element;
	};
	const appendInitialChild = (parent, child) => {
	    parent.appendChild(child);
	};
	const createTextInstance = (content) => {
	    return document.createTextNode(content);
	};
	const appendChildToContainer = appendInitialChild;

	let nextEffect = null;
	const commitMutationEffects = (finishedWork) => {
	    nextEffect = finishedWork;
	    while (nextEffect !== null) {
	        // 向下遍历
	        const child = nextEffect.child;
	        if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
	            child !== null) {
	            nextEffect = child;
	        }
	        else {
	            // 向上遍历
	            up: while (nextEffect !== null) {
	                commitMutationEffectsOnFiber(nextEffect);
	                const sibling = nextEffect.sibling;
	                if (sibling !== null) {
	                    nextEffect = sibling;
	                    break up;
	                }
	                nextEffect = nextEffect.return;
	            }
	        }
	    }
	};
	const commitMutationEffectsOnFiber = (finishedWork) => {
	    const flags = finishedWork.flags;
	    // placement flag
	    if ((flags & Placement) !== NoFlags) {
	        commitPlacement(finishedWork);
	        // 【*****】将 Placement 从该 fiber 的 flags 中移除
	        finishedWork.flags &= ~Placement;
	    }
	};
	const commitPlacement = (finishedWork) => {
	    {
	        console.warn('执行Placement操作', finishedWork);
	    }
	    // parent DOM
	    const hostParent = getHostParent(finishedWork);
	    // finishedWork DOM
	    if (hostParent !== null) {
	        appendPlacementNodeIntoContainer(finishedWork, hostParent);
	    }
	};
	// 获得父级的fiber节点
	function getHostParent(fiber) {
	    let parent = fiber.return;
	    while (parent) {
	        const parentTag = parent.tag;
	        if (parentTag === HostComponent) {
	            return parent.stateNode;
	        }
	        if (parentTag === HostRoot) {
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    {
	        console.warn('未找到 host parent');
	    }
	    return null;
	}
	function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        appendChildToContainer(finishedWork.stateNode, hostParent);
	        return;
	    }
	    const child = finishedWork.child;
	    if (child !== null) {
	        appendPlacementNodeIntoContainer(child, hostParent);
	        let sibling = child.sibling;
	        while (sibling !== null) {
	            appendPlacementNodeIntoContainer(sibling, hostParent);
	            sibling = sibling.sibling;
	        }
	    }
	}

	// 递归中的归
	const completeWork = (wip) => {
	    const newProps = wip.pendingProps;
	    const current = wip.alternate;
	    switch (wip.tag) {
	        case HostComponent:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // 1. 构建 DOM
	                const instance = createInstance(wip.type);
	                // 2. 将 DOM 插入到 DOM 树中
	                appendAllChildren(instance, wip);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostText:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // 1. 构建 DOM
	                const instance = createTextInstance(newProps.content);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostRoot:
	            bubbleProperties(wip);
	            return null;
	        default:
	            {
	                console.warn('completeWork未处理的类型', wip);
	            }
	            break;
	    }
	};
	// 在 parent 节点下插入 wip 节点
	function appendAllChildren(parent, wip) {
	    let node = wip.child;
	    while (node !== null) {
	        if (node.tag === HostComponent || node.tag === HostText) {
	            appendInitialChild(parent, node?.stateNode);
	        }
	        else if (node.child !== null) {
	            // 向下查找
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        if (node === wip) {
	            return;
	        }
	        while (node.sibling === null) {
	            if (node.return === null || node.return === wip) {
	                return;
	            }
	            // 向上查找
	            node = node?.return;
	        }
	        node.sibling.return = node.return;
	        node = node.sibling;
	    }
	}
	// 冒泡处理子树的flags
	function bubbleProperties(wip) {
	    let subtreeFlags = NoFlags;
	    let child = wip.child;
	    // 遍历处理 wip.child 及 wip.child.sibling
	    while (child !== null) {
	        subtreeFlags |= child.subtreeFlags;
	        subtreeFlags |= child.flags;
	        child.return = wip;
	        child = child.sibling;
	    }
	    wip.subtreeFlags |= subtreeFlags;
	}

	let workInProgress = null;
	function prepareFreshStack(root) {
	    workInProgress = createWorkInProgress(root.current, {});
	}
	function scheduleUpdateOnFiber(fiber) {
	    // TODO 调度功能
	    // 从当前触发更新的 fiber 一直向上找到 fiberRootNode
	    const root = markUpdateFromFiberToRoot(fiber);
	    renderRoot(root);
	}
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent !== null) {
	        node = parent;
	        parent = node.return;
	    }
	    if (node.tag === HostRoot) {
	        return node.stateNode;
	    }
	    return null;
	}
	function renderRoot(root) {
	    // 初始化
	    prepareFreshStack(root);
	    do {
	        try {
	            workLoop();
	            break;
	        }
	        catch (error) {
	            {
	                console.warn('workLoop发生错误', error);
	            }
	        }
	        workInProgress = null;
	    } while (true);
	    const finishedWork = root.current.alternate;
	    root.finishedWork = finishedWork;
	    // 根据 wip fiberNode树 和 树中的 flags 进行渲染
	    commitRoot(root);
	}
	function commitRoot(root) {
	    const finishedWork = root.finishedWork;
	    if (finishedWork === null) {
	        return;
	    }
	    {
	        console.warn('commit阶段开始', finishedWork);
	    }
	    // 重置
	    root.finishedWork = null;
	    // 判断是否存在 commit 3个子阶段需要执行的操作
	    // root substeeFlags & root flags 中是否有副作用，通过位与运算判断
	    const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
	    const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
	    if (subtreeHasEffect || rootHasEffect) {
	        // beforeMutation
	        // mutation placement
	        commitMutationEffects(finishedWork);
	        root.current = finishedWork;
	        // layout
	    }
	    else {
	        root.current = finishedWork;
	    }
	}
	function workLoop() {
	    while (workInProgress !== null) {
	        performUnitOfWork(workInProgress);
	    }
	}
	function performUnitOfWork(fiber) {
	    const next = beginWork(fiber);
	    fiber.memoizedProps = fiber.pendingProps;
	    if (next === null) {
	        completeUnitOfWork(fiber);
	    }
	    else {
	        workInProgress = next;
	    }
	}
	function completeUnitOfWork(fiber) {
	    let node = fiber;
	    do {
	        completeWork(node);
	        const sibling = node.sibling;
	        // 存在sibling时，将workInProgress设为sibling
	        if (sibling !== null) {
	            workInProgress = sibling;
	            return;
	        }
	        // 不存在sibling时，将workInProgress设为父fiberNode
	        node = node.return;
	        workInProgress = node;
	    } while (node !== null);
	}

	// 创建 fiberRootNode
	function createContainer(container) {
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	// 更新 container
	function updateContainer(element, root) {
	    const hostRootFiber = root.current;
	    // 创建 update（这里的element可能是一个组件ReactElement）
	    const update = createUpdate(element);
	    // 将 update 放入 updateQueue 中
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    // 开始调度
	    scheduleUpdateOnFiber(hostRootFiber);
	    return element;
	}

	/**
	 * react中 createRoot的使用方式：ReactDOM.createRoot(root).render(<App/>)
	 * 1. 返回一个对象，对象中有一个render方法
	 */
	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            updateContainer(element, root);
	        }
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
